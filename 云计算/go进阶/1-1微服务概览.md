[toc]

# 微服务概览


## 原始架构


**单体架构**

也叫巨石架构，尽管也是模块化逻辑，但是最终它还是会打包并部
署为单体式应用。

其中最主要问题就是
- 应用太复杂，以至于任何单个开发者都不可能搞懂它。
- 应用无法扩展，可靠性很低
- 敏捷性开发和部署变的无法完成


解决思路：
- 化繁为简，分而治之


## 微服务的起源

SOA(Service-Oriented Architecture) 面向服务的架构，SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。

SOA的特点：
- **小即是美**：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。
- **单一职责**：一个服务也只需要做好一件事，专注才能做好。
- **尽可能早地创建原型**：尽可能早的提供服务 API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。
- **可移植性比效率更重要**：服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和移植性



可以把微服务当成是一种SOA的实践。


## 微服务的定义

- 围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。
- 微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活




## 微服务的优缺点

**优点**

- **原子服务**，一个服务只做一件事情
- **独立进程**，一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处
- **隔离部署**，每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本去中心化服务治理
- **去中心化服务治理**
    - **数据去中心化**，每个服务独享自身的数据存储设施(缓存，数据库等)，不像传统应用共享一个缓存和数据
    库，这样有利于服务的独立性，隔离相关干扰
    - **治理去中心化**，热点治理，
    - **技术去中心化**，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的




**缺点**

- 微服务应用是分布式系统，由此会带来固有的复杂性。
    - 开发者不得不使用 RPC 或者消息传递，来实现进程间通信；
        - 例如，服务A -> 服务B -> 服务C， 每个服务都是通过循环大量访问下游，那么下游的请求数量会剧增。常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡
    - 必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。
        - 例如：服务A -> 服务B -> 服务C ，如果是串行，那么所花费的时间就是A+B+C，如果 服务B 失效，那么就会ABC都出错，需要代码处理这些问题。 
- 分区的数据库架构，同时更新多个业务主体的事务很普遍。
    - 这种事务对于单体式应用来说很容易，因为只有一个数据库。
    - 在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。
- 测试一个基于微服务架构的应用也是很复杂的任务。
- 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。
- 对运维基础设施的挑战比较大。




## 微服务的组件服务化

传统实现组件的方式是通过库（library），库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程

用Go实施一个微服务需要：

1. **Kit**: 一个微服务的基础库，也就是框架，例如Beego，Gin
2. **Service**: 业务代码 + Kit依赖 + 第三方依赖，组成的业务微服务
3. **RPC + Message Queue**: 轻量级通信

本质上等同于，多个微服务组合（compose）完成了一个完整的用户场景（user case）




# 微服务设计


## 微服务的分层与安全

![微服务的分层与安全](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1-APIGateway.png?raw=true)


## 微服务的拆分


**有个基本的原则：**

**CQRS**，将应用程序分为两部分：命令端和查询端。

- 命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。
- 查询端通过针对一个或多个物化视图执行查询来处理查询
- 这些物化视图通过订阅数据更改时发出的事件流而保持最新。

例如：

在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库 binlog *以及订阅* binlog *的中间件* canal，将我们的稿件结果发布到消息队列 Kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。

![微服务拆分稿件服务CQRS](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%A8%BF%E4%BB%B6%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86CQRS.png?raw=true)



## 微服务安全





对于外网的请求来说，我们通常在 API Gateway 进行统一的认证拦截，一旦认证成功，我们会使用 JWT 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 校验 Token 完整性后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，<u>建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务</u>。

- *API Gateway -> BFF -> Service*
- *Biz Auth -> JWT -> Request* *Args*

对于服务内部，一般要区分身份认证和授权。

- *Full Trust*
- *Half Trust*
- Zero Trust

![微服务安全](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8.png?raw=true)




# 服务发现

服务端发现有两种模式：
- 客户端发现
- 服务端发现


![服务发现](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.png?raw=true)



- 客户端发现
    - 直连，比服务端服务发现少一次网络跳转
    - Consumer 需要内置特定的服务发现客户端和发现逻辑
        - 可以将负载均衡逻辑下放到 sidecar 中进行解耦
- 服务端发现
    - Consumer 无需关注服务发现具体细节，只需知道服务的 DNS 域名即可
    - 支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失，基础设施会比较复杂
        - B 站这边采用的是客户端发现的模式，我们公司用的更多的是服务端发现的模式