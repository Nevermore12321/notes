[toc]

# 658. 找到k个最接近的元素



## 题目描述



> 给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。



整数 a 比整数 b 更接近 x 需要满足：

- $|a - x| < |b - x|$ 或者

- $|a - x| == |b - x|$ 且 $a < b$



**示例**：

- 示例一：
  
  ```shell
  输入：arr = [1,2,3,4,5], k = 4, x = 3
  输出：[1,2,3,4]
  ```

- 示例二：
  
  ```shell
  输入：arr = [1,2,3,4,5], k = 4, x = -1
  输出：[1,2,3,4]
  ```



## 算法解析：二分搜索+双指针



题目意思很明确：

- 找到 arr 数组中与 x 距离最短的 k 个值，如果距离相等，取值较小者。

- 其中，arr 数组是升序的



首先想到的就是一个一个找，将所有的距离值存入一个新数组中，在寻找k个距离最小的。



但是这种方法忽略了 arr 的一个特性就是单调递增。利用 arr 的升序的性质，完全可以使用 **二分搜索** 。

可以想象一下，距离最小，也就是 $|arr[i] - x|$ 值最小，那么 arr 数组中哪个部分距离最小呢？毫无疑问，arr 数组中值为 x 或者，值最接近 x 的附近，距离最小。



那么可以利用二分搜索：

- 先利用二分搜索，在 arr 数组中找到 **第一个 等于 x** 或者 如果没有等于 x 的值，找到**第一个大于 x 的值** 的下标索引 pos， 那么这附近肯定距离最小。

- 利用双指针，找到 k 个 pos 附近的 距离最小的值
  
  - 初始化左指针 `i := pos` , 右指针 `j := pos`
  
  - 在 i 和 j 没有越界的情况下，比较 $|arr[i]-x|$ 和 $|arr[j]-x|$ 的大小：
    
    - $|arr[i]-x| <= |arr[j]-x|$ 那么说明 左指针 i 的距离最小，i 继续左移
    
    - $|arr[i]-x| > |arr[j]-x|$ 那么说明吗 右指针 j 的距离最小，j 继续右移
    
    - 直到找到 k 个距离最小的元素





## Golang 代码

```go

```



## 复杂度分析


