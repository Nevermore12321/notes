# 保护模式-特权级

[toc]

## 一致代码段和非一致代码段

在操作系统中，我们有些高特权级的代码是希望被低特权级的程序所访问的，比如一些库函数，于是我们将这些高特权级代码放在一个叫做**一致代码段**的段里。而有些高特权级的代码，我们并不想让低特权级的程序所访问，于是我们把他们放在一个叫做**非一致代码段**的段里。

具体来说，当通过call或者jmp指令转移到其它段时（即访问其他段），当转移的目标是一个优先级更高的一致代码段时，我们是可以进行访问的，但是当前的特权级会被延续下去；当转移的目标是一个优先级更高的非一致代码段时，这时的访问会引起常规保护错误（除非使用调用门或任务门）。



在段描述符位图中，

- **一致位**，在描述符属性中TYPE(包含4个二进制位)字段的第2位。
- **S 描述符类型标志 (descriptor type)** ，指明了一个段描述符是一个<u>系统段描述符（该标志位为 0）</u>，还是一个<u>代码或数据段描述符（该标志位为 1）</u>

当 S=1 时，

- 当S=1，type的最高有效位为0时，该段描述符指向一个**数据段**；
- 当S=1，type的最高有效位为1时，该段描述符指向一个**代码段**。



所以，对代码段来说，type 的最高位为1，剩余三位分别表示一致位(C)、读写位(W)、访问位(A)

- 一致位：置1时表示一致码段，置0时表示非一致码段；
- 读写位：置1时表示可读可写，置0时表示只读；
- 访问位：置1时表示已访问，置0时表示未访问。

**一致代码段往往是用在内核共享的段，这些段是允许应用程序去访问的，而不需要内核转移到应用程序中来访问这些 共享的资源。**



对于一致代码段，有以下规则：

- 特权级高的程序不允许访问特权级低的数据。比如，核心态不允许调用用户态的数据。
- 特权级低的程序可以访问到特权级高的数据，但是访问程序的特权级不会发生变化。比如，用户态访问内核态共享的资源时，不会变成内核态。

而对于非一致代码段，则有着不同的规则：

- 只允许同级访问。
- 绝对禁止不同级程序访问。即内核态不能访问用户态，用户态也不能访问内核态。



之所以这么做是为了系统的安全性考虑，分离内核和用户程序，使内核不能被用户程序干涉，同时避免使用户态程序修改内核态的逻辑，导致在内核态下执行 用户程序的代码。上面所说的是代码段，而数据段则全都是非一致的，这意味着不可能被低特权级的代码访问到。然而，与代码段不同的是，数据段可以被更高特权级的代码访问到，而不需要使用特定的门。规则总如如下:

|                    | 特权级 低 -> 高 | 特权级 高 -> 低 | 相同特权级之间 |               适用于何种代码               |
| :----------------: | :-------------: | :-------------: | :------------: | :----------------------------------------: |
|    一致性代码段    |       YES       |       NO        |      YES       | 不访问受保护资源，和某些异常处理的系统代码 |
|   非一致性代码段   |       NO        |       NO        |      YES       |   避免低特权级的程序访问而保护起来的代码   |
| 数据段(总是非一致) |       NO        |       YES       |      YES       |                                            |





## 特权级

### 1. CPL、RPL和DPL

处理器通过识别 CPL、DPL、RPL 这 3 种特权级进行特权级检验

- **CPL(Current Privilege Level)** ：是当前进程的权限级别，
    - 是当前正在执行的代码所在的段的特权级，存在于 cs 和 ss 寄存器的低两位。
    - <u>CPL 等于代码所在的段的特权级</u>。当程序转移到不同特权级的代码段时，处理器将改变 CPL。在遇到一致代码段时，情况稍稍有点特殊，一致代码段可以被相同或者更低特权级的代码访问。当处理器访问一个与 CPL 特权级不同的一致代码段时，CPL 不会被改变
    - 可以看成是段描述符未加载入 CS 前，该段的 DPL，加载入 CS 后就存入 CS 的低两位，所以叫做 CPL，其值就等于原段DPL的值



- **RPL(Request Privilege Level)** ：是进程对段访问的请求权限， 是对于段选择子而言的
    - 每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且 RPL 对每个段来说不是固定的，两次访问同 一段时的RPL可以不同。
    - RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样它对该段仍然只有特权为3的访问权限。处理器通过检查RPL和CPL来确认一下请求是否合法。即便提出访问请求的段有足够的特权级，如果RPL不够也是不行的。
    - 以CPL来访问段DPL所出示的“证件(RPL)”，如出示的“证件”权级范围在CPL之内且满足DPL的特权检查规则：DPL >= max{CPL,RPL}，就能正常通过DPL；反之则不会通过还会发生错误
    - 操作系统过程往往用RPL来避免低特权级应用程序访问高特权级段内的数据。当操作系统过程（被调用过程）从一个应用程序 （调用过程）接收到一个选择子时，将会把选择子的RPL设成调用者的特权级。于是，当操作系统用这个选择子去访问相应的段时，处理器将会调用过程的特权级 （已经被存到RPL中），而不是更高的操作过程的特权级（CPL）进行特权检验。这样，RPL就保证了操作系统不会越俎代疱地代表一个应用程序去访问一个段，除非这个程序本身是有权限的。
    - 可以理解位调用方的 CPL 是基础，通过 CPL 可以有不同的访问权限（RPL，RPL 的权限必须小于等于 CPL），被调用的段检查，权级范围在CPL之内且满足DPL的 特权检查规则：DPL >= max{CPL,RPL}，就能正常通过DPL；反之则不会通过还会发生错误。



- **DPL(Descriptor Privilege Level)** ：存储在段描述符中，规定访问该段的权限级别，每个段的DPL固定。

    - DPL 表示段或者门的特权级。它被存储在段描述符或者门描述符的 DPL 字段中

    - 当进程访问一个段时，需要进程特权级检查，一般要求**DPL >= max {CPL, RPL}** 。当当前代码段试图访问一个段或者门时，DPL将会和CPL以及段或门选择子的RPL相比较，根据段或者门类型的不同，DPL将会被区别对待，下面介绍一下各种类型的段或者门的情况：

        - 数据段：DPL规定了可以访问此段的**最低特权级** 。比如，一个数据段的DPL是1，那么只有运行在CPL为0或者1的程序才有权访问它。

        - 非一致代码段（不使用调用门的情况下）：DPL规定访问此段的特权级。比如，一个非一致代码的特权级为0，那么只有CPL为0的程序才可以访问它。

        - 调用门：DPL规定了当前执行的程序或任务可以访问此调用门的**最低特权级** （这与数据段的规定是一致的）。

        - 一致代码段：DPL规定了访问此段的**最高特权级** 。比如，一个一致代码段的DPL是2，那么CPL为0和1的程序将无法访问此段。

        - TSS：DPL规定了可以访问此TSS的**最低特权级** （这与数据段的规定是一致的）。

​     下面打一个比方，中国官员分为6级国家主席1、总理2、省长3、市长4、县长5、乡长6，假设我 是当前进程，级别总理（CPL=2）,我去聊城市(DPL=4)考察(呵呵),我用省长的级别(RPL=3 这样也能吓死他们)去访问,可以吧，如果我用县长的级别，人家就不理咱了(你看看电视上的微服私访，呵呵)，明白了吧！为什么采用RPL，是考虑到安全的问题，就好像你明明对一个文件拥有写权限，为什么用只读打开它呢，还不是为了安全！





下面做一个实验：

将在第三篇的 保护模式之LDT 中的代码，做一些小的修改，把先前例子中的数据段描述符的 DPL 修改一下。

将LABEL_DESC_DATA对应的段描述符的 DPL 修改为 1：

```assembly
LABEL_DESC_DATA:	Descriptor			0,		 DataLen - 1,	DA_DRW + DA_DPL1	; Data 数据段
```

此时的 RPL 不变，还是原来的(还是 RPL = 0)：

```assembly
SelectorData			equ			LABEL_DESC_DATA 	- LABEL_GDT
```



编译运行，都正常，说明 RPL = 0 ，且 CPL =0，可以访问 DPL=1 的数据段（非一致性）



继续修改，将数据段的选择子 RPL 修改为 3，

```assembly
SelectorData			equ			LABEL_DESC_DATA 	- LABEL_GDT + SA_RPL3
```



再次编译运行，这时候运行出错 ` RPL & CPL must be <= DPL`：

说明，RPL = 3，且 CPL=0，不能访问 DPL=1 的数据段。



### 2. 不同特权级代码段之间的转移

序从一个代码段转移到另一个代码段之前，目标代码段的选择子会被加载到cs中。作为加载过程的一部分，处理器将会检查描述符的界限、类型、特权级等内容。如果检验成功，cs 将被加载，程序控制将转移到新的代码段中，从 eip 指示的位置开始执行。

程序控制转移的发生，可以是由指令 jmp、 call、 ret、 sysenter、sysexit、 int n 或 iret 引起的，也可以由中断和异常机制引起。

使用jmp或call指令可以实现下列 4 种转移：

1. 目标操作数包含目标代码段的段选择子。

2. 目标操作数指向一个包含目标代码段选择子的调用门描述符。

3. 目标操作数指向一个包含目标代码段选择子的 TSS。

4. 目标操作数指向一个任务门这个任务门指向一个包含目标代码段选择子
  的 TSS。

  

这 4 种方式可以看做是两大类，一类是通过jmp和call的直接转移，上述第1种，另一类是通过某个描述符的间接转移(上述第2、3、4种)。