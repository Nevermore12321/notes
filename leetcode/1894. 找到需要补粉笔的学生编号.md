[TOC]

# 1894. 找到需要补粉笔的学生编号

## 题目描述

> 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。

> 给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。

>  请你返回需要 补充 粉笔的学生 编号 。

**示例**：

- 示例一：
  
  ```shell
  输入：chalk = [5,1,5], k = 22
  输出：0
  解释：学生消耗粉笔情况如下：
  - 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。
  - 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。
  - 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。
  - 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。
  - 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。
  - 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。
  编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。
  ```

- 示例二：
  
  ```shell
  输入：chalk = [3,4,1,2], k = 25
  输出：1
  解释：学生消耗粉笔情况如下：
  - 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。
  - 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。
  - 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。
  - 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。
  - 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。
  - 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。
  - 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。
  - 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。
  - 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。
  编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。
  ```

**提示：**

- `chalk.length == n`
- `1 <= n <= 105`
- `1 <= chalk[i] <= 105`
- `1 <= k <= 109`

## 算法解析

简单分析一下题目，翻译成数学问题就是，一个数组 chalk，对元素进行循环累加，找到第一个累加值大于 k 的元素下标。

### 解法一：模拟

#### 解析

这道题目可以分成两种情况：

1. 在第一遍循环 chalk 数组，进行累加的过程，就已经找到了 第一个大于 k 的元素

2. 在第n遍循环 chalk 数组，累加过程，找到了 第一个大于 k 的元素

第一种情况，很简单，在累加过程中，就可以判断。

针对第二种情况，只要找到最后一遍遍历时还剩的 k 值记为 $k'$，那么再寻找最后一轮中累加和第一个大于 $k'$ 的元素下标即可。

那么如何寻找最后一轮还剩的 k 值呢？很简单，如果 chalk 数组的所有元素和为 total，那么最后一轮还剩的 k 值 $k'$ 为：

$$
k' = k \% total(模运算)
$$

#### Golang 代码

```go
func chalkReplacer(chalk []int, k int) int {
    total := 0
    // 求 chalk 数组的所有元素和
    for _, v := range chalk {
        total += v
    }

    // 这里计算最后一轮还剩下的 k' 
    round := k % total

    // 继续从 chalk 数组的 0 下标开始找，找到累加和第一个大于 k' 的元素下标
    for i, v := range chalk {
        if round < v {
            return i
        } else {
            round -= v
        }
    }
    return 0
}
```

上面代码可以利用递归简化：

```go
func chalkReplacer(chalk []int, k int) int {
    n := len(chalk)
    total := 0

    // 同样计算 chalk 数组的综合，这里在有个注意点，如果在第一轮就能找到第一个大于 k 的元素
    for i := 0; i < n; i++ {
        total += chalk[i]
        if total > k {
            return i
        }
    }

    // 通过 递归 ，将k值变为最后一轮还剩的 k'
    return chalkReplacer(chalk, k%total)

}
```

#### 复杂度分析

- **时间复杂度**：$O(n)$，其中 n 是数组 $\textit{chalk}$ 的长度。我们最多遍历数组 $\textit{chalk}$ 两次，第一次求出粉笔的总量 $\textit{total}$，第二次找出答案。

- **空间复杂度**：$O(1)$

### 解法二：前缀和+二分搜索

#### 解析

对第一种算法进行优化，第一种算法是找到最后一轮的 k' 值后，遍历搜索。

可以通过 二分搜索进行优化，将 chalk 变成前缀和的数组，这样就是单调递增的，满足二分搜索的要求，然后找到最后一轮的 k' 值后，利用二分搜索找到签注和数组中第一个大于 k' 的元素下标即可。

#### Golang 代码

```go
func chalkReplacer(chalk []int, k int) int {
    // 注意：前缀和从 第二个元素开始累加，这里要判断第一个元素是不是已经超过 k 了
    if chalk[0] > k {
        return 0
    }
    n := len(chalk)

    // 计算前缀和，同样是判断第一轮中有没有累加超过 k 的元素
    // 这里循环结束会将 chalk 数组，对应元素下标 i 变成 [0.i] 的元素累加和，也就是 前缀和
    for i := 1; i < n; i++ {
        chalk[i] += chalk[i-1]
        if chalk[i] > k {
            return i
        }
    }

    // 计算最后一轮中的 k’
    restK := k % chalk[n-1]

    // 使用二分搜索找到 前缀和数组中，第一个大于 k' 的元素下标
    l, r := 0, n-1
    for l <= r {
        mid := l + (r-l)/2
        if chalk[mid] <= restK {    // 这里相等也要继续找，要找到大于 target 的元素下标
            l = mid + 1
        } else {
            r = mid - 1
        }
    }

    return l
}
```

#### 复杂度分析

- **时间复杂度**：$O(n)$
  
  - 其中 n 是数组 $\textit{chalk}$ 的长度
  
  - 计算前缀和的时间复杂度为 $O(n)$
  
  - 二分查找的时间复杂度为 $O(\log n)$
  
  - 因此总时间复杂度为 $O(n)$

- **空间复杂度**：$O(1)$
