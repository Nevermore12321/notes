[TOC]

# 441. arranging coins

## 题目描述

> 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

> 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。

**示例：**

- 示例1

```shell
输入：n = 5
输出：2
解释：因为第三行不完整，所以返回 2 。
```

- 示例2

```shell
输入：n = 8
输出：3
解释：因为第四行不完整，所以返回 3 。
```

**提示：**

- `$1 <= n <= 2^31 - 1$`

## 算法解析

题目的意思就是，有 n 个硬币，按照 第一列一个，第二列两个，第 i 列 i 个堆放硬币，把所有 n 个硬币全部按照这种形式对方，那么有可能最后一列放不满，返回完整的列数。

翻译成数学问题，就是给一个整数 n，从 [1, n] 中找到一个整数 k，使得 

- `$1 + 2 + ... + k  <= n$` ，并且

- `$1 + 2 + ... + k + k+1 > n$`

[1, n] 升序，满足二分搜索，这里需要注意的是，需要寻找的这个数，是需要计算的，也就是利用等差数列为1的前 n 项的和公式：

```math
n \ast (n + 1) \div 2
```

整个过程就是：

- 找到 mid，计算 前 mid 项 和 ：`$res = mid * (mid + 1) / 2$`

- 如果计算结果 res = n，返回 mid

- 如果计算结果 res < n, 继续向右边寻找

- 如果计算结果 res > n, 继续向左边寻找

## Golang 代码

```go
func nextGreatestLetter(letters []byte, target byte) byte {
    l, r := 0, len(letters)-1
    // 二分搜索，注意点就是，求找 第一个比目标字母大的字母
    // 因此如果找到目标字母，继续向右寻找
    for l <= r {
        mid := l + (r-l)/2
        if letters[mid] > target {
            r = mid - 1
        } else {
            l = mid + 1
        }
    }

    // 如果 l 比最后一个还大，那么就返回第一个 字母
    if l >= len(letters) || l < 0 {
        return letters[0]
    }

    return letters[l]
}
```

## 复杂度分析

- **时间复杂度**：`$O(logn)$`

- **空间复杂度**：`$O(1)$`
