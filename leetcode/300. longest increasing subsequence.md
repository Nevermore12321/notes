[TOC]

# 300. longest increasing subsequence

## 题目描述

>  给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 

**示例：**

- 示例 1：
  
  ```shell
  输入：nums = [10,9,2,5,3,7,101,18]
  输出：4
  解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
  ```

- 示例 2：
  
  ```shell
  输入：nums = [0,1,0,3,2,3]
  输出：4
  ```

- 示例3：
  
  ```shell
  输入：nums = [7,7,7,7,7,7,7]
  输出：1
  ```

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

## 算法解析

最长严格递增子序列，求最值，一般使用动态规划

**动态规划问题的⼀般形式就是求最值**。

**求解动态规划的核⼼问题是穷举**

动态规划的过程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。**

如何列出正确的状态转移⽅程？

1. **确定 base case**，这个很简单，显然数组长度为0时，返回0。

2. **确定「状态」**，**也就是原问题和⼦问题中会变化的变量**。该问题中，也就是最大递增子序列的长度了。

3. **确定「选择」，也就是导致「状态」产⽣变化的⾏为**。最大递增子序列的长度为什么变化呢，因为你在选择原数组的每个元素时，每一个元素，与其之前的元素中，都会有一个最大长度递增的子序列，就相当于遍历每一个原数组元素。每个元素都有一个最大递增子序列，就是「选择」。
   4、**明确 dp 函数/数组的定义**。一般使用自底向上的解法，所以会有⼀个递归的 dp 函数，⼀般来说函数的参数就是状态转移中会变化的量，也就是上⾯说到的「状态」；函数的返回值就是题⽬要求我们计算的量。就本题来说，状态只有⼀个，即「最大递增子序列的长度」

### 解法一：动态规划

#### 解析

根据上面的描述，最主要的问题就是求状态转移方程，上面也讲了 dp 其实是一个函数或数组，dp 就是描述状态转移的过程，在本题目中：

定义 $\textit{dp}[i]$ 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度（包括第 i 个）

- dp 的输入参数就是原数组的索引值

- dp 的输出就是原数组中，以输入参数索引（包括该元素）为结尾的，最大递增子序列的长度

那么这道题目的状态转移方程为，$\textit{dp}[i]$ 表示选择$\textit{nums}[i]$，并且以$\textit{nums}[i]$结尾的最长上升子序列的长度。：

$$
dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]
$$

总结来说：

- dp 可以为一个数组

- dp 数组的每个位置，表示的就是原数组对应位置为结尾的，最大递增子序列的长度

- 两层循环，i：`1～nums.length`，`j：0～i`，如果 `nums[i] > nums[j]`，则构成一个上升对，`dp[i]` 就从 `dp[i]`, `dp[j]+1`两个种选择较大者，最后返回dp数组总的最大数

![动态规划图解](https://github.com/Nevermore12321/LeetCode/blob/dev/Binay-Search/300_longest_increasing_subsequence/300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E5%9B%BE%E8%A7%A3.gif?raw=true)

#### Golang 代码

```go
func lengthOfLIS(nums []int) int {
    //  base case 长度为0，则返回0
    if len(nums) == 0 {
        return 0
    }
    //  状态转移方程, dp 每个位置，表示原数组 nums 中对应位置结尾的，最大递增自序列的长度
    var dp = make([]int, len(nums))
    dp[0] = 1
    // 返回结果，最大递增子序列的长度
    maxLen := 1

    max := func(a, b int) int {
        if a < b {
            return b
        }
        return a
    }

    //  动态规划，典型的双层循环，外层遍历 整个nums 数组
    for i := 1; i < len(nums); i++ {
        dp[i] = 1
        // 内层，子问题，每个原数组元素，求出一个最大递增子序列的长度
        for j := i - 1; j >= 0; j-- {
            if nums[i] > nums[j] {                // 求出 i 位置前的最大递增子序列，并且 nums[i] 比子序列的最后一个元素大，才可以合并成一个更大的子序列
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        maxLen = max(maxLen, dp[i])            // 每个元素的寻找，都更新 maxLen ，如果长度更大，就更新
    }
    return maxLen
}
```

#### 算法复杂度

- **时间复杂度**：$O(n^2)$，其中 n 为数组 $\textit{nums}$ 的长度。动态规划的状态数为 n，计算状态 $dp[i]$ 时，需要 $O(n)$ 的时间遍历 $dp[0 \ldots i-1]$ 的所有状态，所以总时间复杂度为 $O(n^2)$

- **空间复杂度**：$O(n)$，需要额外使用长度为 n 的 dp 数组。

### 解法二：贪心+二分搜索

考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们**希望每次在上升子序列最后加上的那个数尽可能的小**。

还是以动态规划的思路，但是 dp 这里不存储最大子序列的长度，而是存储一个当前的值最小的，长度最长的，递增子序列。

思路：

1. 准备 tail 数组存放最长上升子序列，核心思想就是**越小的数字越要往前放**，这样后面就会有更多的数字可以加入tails数组。

2. 将nums中的数不断加入tail
   
   - 当nums中的元素比tail中的最后一个大时 可以放心push进tail
   
   - 否则进行二分查找，让比较小的数二分查找到合适的位置，让后面有更多的数字与这个数形成上升子序列

![二分法图解](https://github.com/Nevermore12321/LeetCode/blob/dev/Binay-Search/300_longest_increasing_subsequence/300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E5%9B%BE%E8%A7%A3.gif?raw=true)

#### Golang 代码

```go
func lengthOfLIS(nums []int) int {
    //  base case 长度为0，则返回0
    if len(nums) == 0 {
        return 0
    }
    // 贪心的 tails 数组，存放当前位置结尾的，长度最长的，值最小子序列
    var tails = make([]int, 1)
    maxLen := 1
    tails[0] = nums[0]

    // 类似动态规划，遍历最外层
    for i := 1; i < len(nums); i++ {
        // 如果 当前位置 i 的元素，比 tails 的最后一个元素还大，直接放到结尾，形成一个更长的子序列
        if nums[i] > tails[maxLen-1] {
            tails = append(tails, nums[i])
            maxLen += 1
        } else {                // 否则使用二分，找到第一个比 nums[i] 的位置，替换
            l, r := 0, maxLen-1
            for l <= r {
                mid := l + (r-l)/2
                if nums[i] > tails[mid] {
                    l = mid + 1
                } else {
                    r = mid - 1
                }
            }
            tails[l] = nums[i]
        }
    }
    return maxLen
}
```

#### 复杂度分析

- **时间复杂度**：$O(n\log n)$。数组 $\textit{nums}$ 的长度为 n，我们依次用数组中的元素去更新 d 数组，而更新 dd 数组时需要进行 $O(\log n)$ 的二分搜索，所以总时间复杂度为 $O(n\log n)$。

- **空间复杂度**：$O(n)$，需要额外使用长度为 n 的 d 数组。
