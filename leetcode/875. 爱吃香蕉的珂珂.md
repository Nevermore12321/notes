[TOC]

# 875. 爱吃香蕉的珂珂

## 题目描述

> 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。

> 珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 h 小时内吃掉所有香蕉的**最小速度 k**（k 为整数）。

## 算法解析

### 思路整理

这道题目的主要思路，与题目 1760 袋子里最少数目的球是一致的。

关键点所在就是将题目转成数学问题。

首先分析题目，有两个变量：

- 吃香蕉的速度 x （单位：根/小时）

- 吃完所有香蕉所有用的小时数 y

这里需要注意一点，**就是吃完一堆后，必须在下一小时吃下一堆**。

很容理解，吃香蕉的速度越快，也就是 x 越大，吃每一堆香蕉所花费的小时数越少，那么吃完所有香蕉需要的小时数越少，也就是 y 越小。

也就是 x 越大，y 越小，现在给定了一个最大的 y，现在要找到最小的 x。

 注意这里，找 x 可以使用二分搜索，为什么呢？

因为 y=f(x) 随着 x 的增加，是单调减少的。那么 找 x 其实就是从：

$$
[f(x_1), f(x_2),..., f(x_n)], f(x_i) 随着 x_i 的增加而减少，f(x_i)是一个递减的数组
$$

找到一个最大（不能超过 h）的 $f(x_i)$ 。

那么完全可以使用二分搜索‘。

### 二分搜索界限

上面整个思路已经理清楚了，现在就要思考怎么找到最小的 x 是得 $f(x)$ 最大。既然使用二分搜索，那么就要确定二分搜索的左右界限。

可以理解，piles 是一堆堆香蕉，那么其实，吃香蕉最大的速度其实就是 piles 香蕉堆中，香蕉最多的那一堆的香蕉数目。为什么呢，因为吃的再多，这一小时内也只能把这一堆香蕉吃完，需要到下一小时开始，才能吃一下堆香蕉。

### 吃完 piles 堆中香蕉花费时间的计算

现在确定了要二分搜索的 x 的界限，那么具体根据什么搜索呢？也就是怎么计算 $f(x)$ 呢？

根据题目的意思，如果吃香蕉的速度为 x 根/小时，那么吃完一堆香蕉所花费的时间可以分成两种情况：

- 该堆香蕉数 $piles[i]$ **可以**整除吃香蕉速度 x，那么花费的时间就是 $piles[i] / x$。例如，9 个香蕉，速度为 3，那么需要 $9/3=3 $；

- 该堆香蕉数$piles[i]$**不能**整除吃香蕉速度 x，那么花费的时间就是 $(piles[i] / x) + 1$ 。例如，10 个香蕉，速度为 3，那么需要 $10/3 + 1=3 + 1 = 4$ ；再例如，4 香蕉，速度为8，那么需要 $4 / 8 + 1 = 0 + 1 = 1$

### 整体思路

1. 确定 x 搜索的左右界限，`l := 1, r := max(piles)`

2. 使用二分搜索找 x，具体搜索过程：
   
   - $f(mid) <= h$ ，说明目前花费的时间比最大小时数 h 小，可以继续减小 x 使得 f(x) 更大，那么取右半部分，l = mid + 1，（因为x增大，f(x) 减小）
   
   - $f(mid) > h$ ，说明目前花费的时间比最大小时数 h 还大，可以继续减小 x 使得 f(x) 小一些，那么取左半部分，r = mid - 1，（因为x增大，f(x) 减小）

## Golang 代码

```go
func minEatingSpeed(piles []int, h int) int {
    // y=f(x) 其中 x 表示吃香蕉的速度，y 表示当吃香蕉的速度为 x 时，吃完需要的小时数
    // x 吃的速度越大，花费的时间y越小。因此 y 随着 x 的增大而减小

    // spend_times 表示计算 y，也就是计算 f(x)
    var spend_times func(int) int
    spend_times = func(x int) int {
        total_times := 0
        for _, v := range piles {
            total_times += int(math.Ceil(float64(v) / float64(x)))
        }
        return total_times
    }

    // maxPile 返回所有堆中香蕉最多的 堆大小
    var maxPile func(arr []int) int
    maxPile = func(arr []int) int {
        maxValue := 0
        for _, v := range arr {
            if v > maxValue {
                maxValue = v
            }
        }
        return maxValue
    }

    // 下面使用二分搜索，现在要找到最小的吃香蕉的速度x
    // l 最终就是第一个等于8 或者第一个小于8 的元素
    l, r := 1, maxPile(piles)

    for l <= r {
        mid := l + (r-l)/2
        if spend_times(mid) > h {
            l = mid + 1

        } else {
            r = mid - 1

        }
    }

    return l
}
```

## 复杂度分析

- **时间复杂度**：$O(n \log m)$
  
  - 令 n 数组长度
  
  - $m = 1e9$ 为最大的 $piles[i]$
  
  - 总复杂度为 $O(n\log{m})$

- **空间复杂度**：$O(1)$
