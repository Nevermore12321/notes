[TOC]

# 633. Sum of Square Numbers

## 题目描述

> 给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a2 + b2 = c` 。

**示例：**

- 示例一：

```shell
输入：c = 5
输出：true
解释：1 * 1 + 2 * 2 = 5
```

- 示例 二：

```shell
输入：c = 3
输出：false
```

**提示：**

- `$0 <= c <= 2^31 - 1$`

## 算法解析

题目很简单，给你一个数 c，找到 a 和 b ，使得 `$a ^2 + b ^ 2 = c$`

要找 a 和 b，并且 a 和 b 一定在 `$[1, \sqrt c]$` 之间。

首先可以想到就是**双指针**，让双指针 i ，j 逼近 a 和 b ，最终找到 a 和 b。

不失一般性，可以假设 `$i \le j$`。初始时 `i=0`，`$j = \sqrt{c}$`
，进行如下操作：

- 如果 `$i^2 + j^2 = c$`，我们找到了题目要求的一个解，返回 `$\text{true}$`；

- 如果 `$i^2 + j^2 < c$` ，此时需要将 i 的值加 1，继续查找；

- 如果 `$a^2 + b^2 > c$`，此时需要将 j 的值减 1，继续查找。

为什么双指针 i 和 j 一定能够夹住 a 和 b 呢？

1. 在移动的过程中 `i < a <= b = j`，
   
   - 此时，j 指针犯下错误，j-- 使得j指针错过了右端点 b
   
   - 但是这是不可能的因为移动前 `i*i+j*j`是小于`a*a+b*b`
   
   - 因为 i < a，根据双指针算法此时只会 i++,故该情况不存在

2. 在移动的过程中 `i = a <= b < j`
   
   - 此时，i 指针犯下错误，i++ 使得j指针错过了左端点 a，同理是不可能的，
   
   - 移动前`i*i+j*j` 大于`a*a+b*b`
   
   - 因为 j > b，此时根据算法只会j--，故该情况不存在

## Golang 代码

```go
func judgeSquareSum(c int) bool {
    // 双指针初始化，从0 到 根号 c
    l, r := 0, int(math.Sqrt(float64(c)))

    // 双指针开始夹逼
    for l <= r {
        res := l*l + r*r
        if res == c {        // 如果等于 c 表示找到
            return true
        } else if res > c {        // 如果 大于 c，表示 右指针过大，右指针向左夹逼
            r -= 1
        } else {                // 否则，左指针过大，左指针向右夹逼
            l += 1
        }
    }
    return false
}
```

## 复杂度分析

- 时间复杂度：`$O(\sqrt c​)$`
  
  - 最坏情况下 a 和 b 一共枚举了 0 到 c​ 里的所有整数。

- 空间复杂度：`$O(1)$`
