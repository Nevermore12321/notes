[toc]

# 三分查找

## 概述



**二分搜索：**

二分查找，用的比较多，就是在一个有序的序列中，查找某一个数值 target。

- 数组必须是**有序**的，所以二分法其实解决的是**单调函数的**求解的问题。

- 通过二分法查找其中的一个元素v，本质其实是查找 **f(x) = v**， x 其实就是表示数组下标

- 二分法使用的场景是单调函数，也就是一次函数。



三分搜索：

搜索二次函数的最小值，也就是求极值



## 算法解析

三分搜索其实就是二分的升级，即将整个数组平均分成三份，根据分割点的不同，来缩小搜索的区间。



分成三份，自然需要两个端点。这两个端点各有一个值，我们分别叫做m1和m2。我们要求的是函数的最小值，所以我们要想极值逼近。



![三分搜索1](https://github.com/Nevermore12321/LeetCode/blob/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E4%B8%89%E5%88%86%E6%90%9C%E7%B4%A2/%E4%B8%89%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%951.jpg?raw=true)



![三分搜索2](https://github.com/Nevermore12321/LeetCode/blob/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E4%B8%89%E5%88%86%E6%90%9C%E7%B4%A2/%E4%B8%89%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%952.jpg?raw=true)



根据上图我们可以看出来，m1和m2的函数值和它们距离极值点的远近是有关系的。**离极值点越近，函数值越小**(也有可能越大，求最大值时)。



求最小值的情况：

- 求最小值时，`f(m2) < f(m1)` ，显然，m2离极值点更近。我们要缩小区间范围，逼近极值点，所以我们应该让 `l = m1`

- 求最小值时，`f(m2) >= f(m1)` ，显然，m1离极值点更近。我们要缩小区间范围，逼近极值点，所以我们应该让 `r = m2`



求最大值的情况：

- 求最小值时，`f(m2) < f(m1)` ，显然，m1离极值点更近。我们要缩小区间范围，逼近极值点，所以我们应该让 `r = m2`

- 求最小值时，`f(m2) >= f(m1)` ，显然，m2离极值点更近。我们要缩小区间范围，逼近极值点，所以我们应该让 `l = m1`





模板例如：

```go
func peakIndexInMountainArray(arr []int) int {
	l, r := 0, len(arr)-1
	for l+1 < r {
		midl := l + (r-l+1)/3
		midr := r - (r-l+1)/3
		if arr[midl] < arr[midr] {
			l = midl
		} else {
			r = midr
		}
	}
	if arr[l] < arr[r] {
		return r
	} else {
		return l
	}
}
```


