[toc]

# 1351. Count Negative Numbers In A Sorted Matrix



## 题目描述

> 给你一个 `m * n` 的矩阵 `grid`，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 `grid` 中 **负数** 的数目。



**示例：**

- 示例 1：

```shell
输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
```

- 示例 2：

```shell
输入：grid = [[3,2],[1,0]]
输出：0
```




提示：

- `$m == grid.length$`

- `$n == grid[i].length$`

- `$1 <= m, n <= 100$`

- `$-100 <= grid[i][j] <= 100$`



**进阶：**

- 设计一个时间复杂度为 `O(n + m)` 的解决方案





## 算法解析

根据题目意思，就是找到二维数组中的，元素值小于0的元素个数。

```shell
[4,   3,  2, -1],
[3,   2,  1, -1],
[1,   1, -1, -2],
[-1, -1, -2, -3]
```



### 解法一：暴力遍历

#### 解析

根据题意，暴力遍历，很简单，遍历所有元素，统计元素值小于0的个数即可。



#### Golang 代码

```go
func countNegatives(grid [][]int) int {
    // 暴力搜索
    count := 0
    for i := 0; i < len(grid); i++ {
        for j := 0; j < len(grid[0]); j++{
            if grid[i][j] < 0 {
                count += 1
            }
        }
    }
    return count
}
```

#### 复杂度分析

- **时间复杂度**：`$O(nm)$`，即矩阵元素的总个数。
- **空间复杂度**：`$O(1)$`。



### 解法二：二分搜索



#### 解析

在暴力遍历的基础上，可以使用二分搜索优化。在查找每一行的数组中，**可以使用 二分搜索，找到第一个小于0的元素索引，那么该元素后的所有元素都满足小于0的要求**。



#### Golang 代码

```go
func countNegatives(grid [][]int) int {
	// 二分搜索
	var binarySearch func(int, int, []int) int
	total := 0

	// 二分搜索，注意，这里返回 l ，第一个小于0的索引
	binarySearch = func(l, r int, nums []int) int {
		if l > r {
			return l
		}
		mid := l + (r-l)/2
		if nums[mid] < 0 {
			return binarySearch(l, mid-1, nums)
		} else {
			return binarySearch(mid+1, r, nums)
		}
	}

	for i := 0; i < len(grid); i++ {
		index := binarySearch(0, len(grid[0])-1, grid[i])
		// 如果 index 不是 -1，说明找到了 小于0的索引，计算当前 i行有多少小于0的元素个数
		if index != -1 {
			total += len(grid[0]) - index
		}
	}
	return total
}

```



#### 复杂度分析

- **时间复杂度**：二分查找一行的时间复杂度为 `$logm$`，需要遍历n行，所以总时间复杂度是`$O(nlogm)$`。
- **空间复杂度**：`$O(1)$`。



### 解法三：倒序查找



#### 解析

之前两种方法都没有用到题目中的另一个特性：**矩阵中的元素按列以递减顺序排列。**

观察下面的矩阵：

```shell
  |  0    1   2   3
0 | [4,   3,  2, -1],
1 | [3,   2,  1, -1],
2 | [1,   1, -1, -2],
3 | [-1, -1, -2, -3]
```

发现：

- `arr[0][3] < 0` : 那么当前元素下的所有元素都小于0

- 也就是按照对角线的方式，往前找



根据这个性质，我们可以倒序查找，复杂度可以降到 `$O(m+n)$`



倒序过程：

- 从右上角开始遍历，`$i = 0, j = grid[0].length - 1$` 

- 如果当前值大于等于 0，那么前面的值肯定都非负，那么直接跳过，进入下一行, 即 i++

- 如果当前值小于 0，那么当前值以及同列下的值都是小于 0 的，那么直接添加，然后进行下一列，即 j--



#### Golang 代码

```go
func countNegatives(grid [][]int) int {
	// 倒序遍历
	count := 0

	// 从第一行的 最后一元素开始找
	for i, j := 0, len(grid[0])-1; i < len(grid) && j >= 0; {
		// 如果当前元素 大于等于0，说明这一整行都是大于等于 0，直接下一行
		if grid[i][j] >= 0 {
			i += 1
		} else {		// 如果当前元素 小于0，说明当前位置的下面所有元素都是 小于0，统计个数，并且继续往前找，看是否还有 小于0的元素
			count += len(grid) - i
			j -= 1
		}
	}
	return count
}

```



#### 复杂度分析

- **时间复杂度**：考虑每次循环变量的起始位置是单调不降的，所以起始位置最多移动 m 次，时间复杂度 `$O(n+m)$`。
- **空间复杂度**：`$O(1)$`。


