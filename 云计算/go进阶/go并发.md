

# Go 内存模型
[TOC]

## 内存模型介绍

- 如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值
- **如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。**
- **为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。**

**执行顺序**

*   在同一个 goroutine 中，读和写一定是按照程序中的顺序执行的。
*   即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。
*   由于重排，不同的 goroutine 可能会看到不同的执行顺序。
*   编译器重拍的例子:
    *   一个goroutine 执行 `a = 1;b = 2;` 语句，编译器在编译时，有可能编译成`b = 2 :a = 1`，但是不会影响整个程序的运行
    *   但是在另一个 goroutine 内，就可能看到 b 在 a 之前更新。

## 内存重排（Memory Reordering）

**内存重排**
用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，**为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。**

**编译器重排**

在代码写好后，编译时，编译器会将代码做一些简单的优化，提高内存的读写效率，但这也造成一些问题。

如下面的例子，源代码如下：

```python
X = 0
for i in range(100):
    X = 1
    print X
```

编译器会将上面的代码优化成：(因为编译器认为，X = 1循环执行没有任何作用)

```bash
X = 1
for i in range(100):
    print X
```

这就会造成一个问题，如果这个时候，有另一个线程 修改了 X 的值，例如将X修改成0值，按照源代码的效果，会输出`1111101111`, 而按照编译器优化后的代码，会输出`1111100000`，这就导致了结果完全不同。

**内存重排的过程**

![内存重排](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E9%87%8D%E6%8B%8D%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true)

分析：

*   先执行 (1) 和 (3)，将他们直接写入 store buffer
*   接着执行 (2) 和 (4)。“奇迹”要发生了：
*   (2) 看了下 store buffer，并没有发现有 B 的值，于是从 Memory 读出了 0
*   (4) 同样从 Memory 读出了 0。最后，打印出了 00。

因此，对于多线程的程序，所有的 CPU 都会提供\*\*“锁”支持，称之为 barrier，或者 fence\*\*。它要求：barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。因此，我们可以用高级点的 atomic compare-and-swap，或者直接用更高级的锁，通常是标准库提供。

## 内存模型

*   如果事件 e1 发生在 e2 前，我们可以说 e2 发生在 e1 后。
*   如果 e1不发生在 e2 前也不发生在 e2 后，我们就说 e1 和 e2 是并发的。也就是 e1 和 e2 是无关联的

**在单一的独立的 goroutine 中先行发生的顺序即是程序中表达的顺序。**

当下面条件满足时，对变量 v 的读操作 r 是被允许看到对 v 的写操作 w 的， 也就是 读操作 可以 看到 写操作 的结果：

*   r 不先行发生于 w
*   在 w 后 r 前没有对 v 的其他写操作

举个例子，在读取 a 变量时，a变量必须先被写入，才可以读取。假设 写操作将 a 写成 1，要确保在读操作之前，没有别的写操作，才能使得 读操作能够读取到1.

为了保证对变量 v 的读操作 r 看到对 v 的写操作 w，要确保 w 是 r 允许看到的唯一写操作。即当下面条件满足时，r 被保证看到 w：

*   w 先行发生于 r
*   其他对共享变量 v 的写操作要么在 w 前，要么在 r 后。

这一对条件比前面的条件更严格，需要没有其他写操作与 w 或 r 并发发生。

因此：**当多个 goroutine 访问共享变量 v 时，它们必须使用同步事件来建立先行发生这一条件来保证读操作能看到需要的写操作**