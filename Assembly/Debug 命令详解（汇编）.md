[TOC]

# Debug 命令详解（汇编）

DEBUG 是 DOS 中的一个外部命令，从 DOS 1.0 起就带有此命令，因此可见此命令的重要性了。

直接将 8086/8087/8088 记忆码合并到内存。

该命令从汇编语言语句创建可执行的机器码。**所有数值都是十六进制格式**，必须按一到四个
字符输入这些数值。在引用的操作代码（操作码）前指定前缀记忆码。

## 读写寄存器指令

### Debug:R（寄存器）

#### r 命令

含义：**显示或改变一个或多个 CPU 寄存器的内容**。

使用：

```shell
r [register-name]
```

- 参数 [register-name] 表示<u>指定要显示其内容的寄存器名，并且可以修改</u>。

- 如果在没有参数的情况下使用，则 <u>r 命令显示所有寄存器的内容以及寄存器存储区域中的标志</u>。

#### 使用说明

##### 1. r - 显示所有寄存器内容

要查看<u>所有寄存器的内容</u>、所有标记的状态和当前位置的指令解码表，请键入以下命令 `r`

<img src="file:///E:/notes/Assembly/pics/debug_r_1.PNG" title="" alt="debug_r_1" data-align="center">

显示内容如下：

- AX、BX、CX、DX

- SP、BP

- SI、DI

- ES、SS、CS、IP、DS

- CS:IP 所指向的内存单元为 `0740:0100`，此处存放的机器码为 `0000`，对应的汇编指令为 `ADD [BX+SI], AL`

##### 2. r 寄存器- 显示/修改特定寄存器的内容

r 命令，携带一个寄存器的名称 [regiseter-name] ，可以查看，或者修改对应寄存器的内容。

<img title="" src="file:///E:/notes/Assembly/pics/debug_r_2.png" alt="debug_r_2" data-align="center">

说明：

- `r 寄存器名称` 可以查看对应寄存器的内容

- 如果在冒号后，直接回车，不修改，如果在冒号后输入十六进制进制数值

- 如果参数寄存器名称不正确，

##### 3. rf - 显示/修改标志状态

要只查看标志的状态，请输入命令 `rf`

![debug_r_3](E:\notes\Assembly\pics\debug_r_3.png)

说明：

若不作修改可按ENTER键，否则在“-”号之后键入修改值，键入顺序任意

R 命令显示标志寄存器标志位状态的含义如下表所示：

| 标 志 名                    | 置  位（值为1） | 复  位（值为0） |
|:------------------------:|:---------:|:---------:|
| 溢出Overflow（是/否）          | OV        | NV        |
| 方向Direction（减量/增量）       | DN        | UP        |
| 中断Interrupt（允许/屏蔽）       | EI        | DI        |
| 符号Sign（负/正）              | NG        | PL        |
| 零Zero（是/否）               | ZR        | NZ        |
| 辅助进位Auxiliary Carry（是/否） | AC        | NA        |
| 奇偶Parity（偶/奇）            | PE        | PO        |
| 进位Carry（是/否）             | CY        | NC        |

## 读写内存指令

### Debug:D（转储）

#### d 命令

含义：**显示一定范围内存地址的内容。**

使用：

```shell
d [range]
```

- range 参数：**指定要显示其内容的内存区域的起始和结束地址，或起始地址和长度**。如果不指定 range，Debug 程序将从以前 d 命令中所指定的地址范围的末尾开始显示 128 个字节的内容。

#### 使用说明

##### 1. d - 显示 CS:IP 开始的内容

如果直接键入 d 命令，那么会显示当前 CS:IP 寄存器中的地址内容。

<img src="file:///E:/notes/Assembly/pics/debug_d_1.png" title="" alt="debug_d_1" data-align="center">

说明：

当使用 d 命令时，Debug 以两个部分显示内存内容：

- 十六进制部分（每个字节的值都用十六进制格式表示）
  
  - 每个显示行显示 16 字节的内容，第 8 字节和第 9 字节之间有一个连字符。每个显示行从 16 字节的边界上开始

- ASCII 码部分（每个字节的值都用 ASCII 码字符表示)。
  
  - 每个非打印字符在显示的 ASCII 部分由句号 (.) 表示。

##### 2. d 段地址:偏移地址 - 显示特定地址开始的内容

如果想自己指定显示某一个特定地址的内容（默认 128 字节），可以将物理地址，转换成 `段地址:偏移地址` 通过 `d 段地址:偏移地址` 查看。（`物理地址 = 段地址 * 16(左移4位) + 偏移地址`）

<img src="file:///E:/notes/Assembly/pics/debug_d_2.PNG" title="" alt="debug_d_2" data-align="left">

注意，这里的偏移地址可以不从 0 开始取，例如如果写 `1000:9`，那么会显示从 `1000:9 - 1000:88` 的内容，一共 128 字节。

##### 3. d 段地址(寄存器CS):开始偏移地址 结束偏移地址 - 显示特定地址开始的具体长度内容

通过添加长度的参数，来查看具体长度的内容：`d 段地址:开始偏移地址 结束偏移地址`

<img src="file:///E:/notes/Assembly/pics/debug_d_3.PNG" title="" alt="debug_d_3" data-align="center">

### Debug:E (键入)

#### e 命令

含义：**将数据输入到内存中指定的地址**。可以按十六进制或 ASCII 格式键入数据。以前存储在指定位置的任何数据全部丢失。

使用：

```shell
e address [list]
```

参数：

- address: <u>指定输入数据的第一个内存位置</u>。

- list: 指定要输入到内存的连续字节中的数据。

#### 使用说明

##### 1. e 段地址:偏移地址 数据列表 - 带数据 list

如果指定 list 参数的值，随后的 e 命令将使用列表中的值替换现有的字节值。如果发生错误，将不更改任何字节值。

List 值可以是<u>十六进制字节或字符串</u>。<u>使用空格、逗号或制表符来分隔值</u>。必须将字符串包括在单或双引号中。

直接修改为十六进制数值：

<img src="file:///E:/notes/Assembly/pics/debug_e_1.png" title="" alt="debug_e_1" data-align="center">

直接修改为字符串：

<img src="file:///E:/notes/Assembly/pics/debug_e_2.png" title="" alt="debug_e_2" data-align="center">

##### 2. e 段地址:偏移地址 - 不带数据 list

如果在没有指定可选的 list 参数的值情况下指定 address 的值，Debug 将显示地址和内容，在下一行重复地址，并等待输入。有以下几种情况：

- <u>替换字节值</u>。在当前值后键入新值。如果键入的值不是有效的十六进制值，或该值包含两个以上的数字，则 Debug 不会回显无效或额外的字符。

- <u>进入下一个字节</u>。 SPACEBAR（空格键），要更改该字节中的值，请在当前值后键入新值。如果按 SPACEBAR（空格键）时，移动超过了 8 位界限，Debug 程序将显示新的一行并在行首显示新地址。

- <u>返回到前一个字节</u>。HYPHEN 键 (-)。可以反复按 HYPHEN 键 (-) 向后移动超过多个字节。在按 HYPHEN 时，Debug 开始新行并显示当前地址和字节值。

- <u>停止执行 e 命令</u>。ENTER 键。在任何字节位置都可以按 ENTER。

<img src="file:///E:/notes/Assembly/pics/debug_e_3.png" title="" alt="debug_e_3" data-align="center">

### Debug:F（填充）

#### f 命令

含义：**使用指定的值填充指定内存区域中的地址**。可以指定十六进制或 ASCII 格式表示的数据。任何以前存储在指定位置的数据将会丢失。

使用：

```shell
f range list
```

参数：

- range: 指定要<u>填充内存区域的起始和结束地址，或起始地址和长度</u>。

- list: **指定要输入的数据**。List 可以由十六进制数或引号包括起来的字符串组成。

注意：

- <u>如果 range 包含的字节数比 list 中的数值大</u>，Debug 将在 list 中<u>反复</u>指派值，直到 range 中的所有字节全部填充。

- 如果在 range 中的<u>任何内存损坏或不存在</u>，Debug 将显示错误消息并停止 f 命令。

- <u>如果 list 包含的数值多于 range 中的字节数</u>，Debug 将忽略 list 中额外的值

#### 使用说明

使用 f 修改某个内存段的值。

<img src="file:///E:/notes/Assembly/pics/debug_f_1.PNG" title="" alt="debug_f_1" data-align="center">

### Debug:S（搜索）

#### s 命令

含义：**在某个地址范围搜索一个或多个字节值的模式**。

使用：

```shell
s range list
```

参数：

- 指定要搜索范围的开始和结束地址。

- 指定一个或多个字节值的模式，或要搜索的字符串。用空格或逗号分隔每个字节值和下一个字节值。将字符串值包括在引号中。

注意：

- <u>如果 list 参数包含多个字节值</u>，Debug 将只显示出现字节值的第一个地址。

- <u>如果 list 只包含一个字节值</u>，Debug 将显示指定范围内出现该值的所有地址。

##### 使用说明

下面示例步骤：

1. 先将 `1000:0 - 1000:f`  内存的内容输出

2. 填充 `1000:0 - 1000:2` 的内存为 a

3. 再将 `1000:0 - 1000:f` 内存的内容输出

4. 搜索 `1000:0 - 1000:2` 内存内容为 a 的地址、

<img src="file:///E:/notes/Assembly/pics/debug_s_1.PNG" title="" alt="debug_s_1" data-align="center">

### Debug:M（移动）

#### m 命令

含义: **将一个内存块中的内容<u>复制</u>到另一个内存块中**。

使用：

```shell
m range address
```

参数:

- range: <u>指定要复制内容的内存区域的起始和结束地址，或起始地址和长度</u>。

- address: <u>指定要将 range 内容复制到该位置的起始地址</u>。

注意：

- **复制操作对现有数据的影响**
  
  - 如果新数据没有写入正在被复制的数据块中的地址，则源数据将保持不变。
  
  - 如果目标块已经包含数据(就象它在覆盖副本操作中一样)，则将改写该数据。（覆盖复制操作是指那些
    目标数据块部分内容覆盖原数据块部分内容的操作。）

- **执行覆盖复制操作**
  
  - m 命令执行目标地址的覆盖复制操作，而不丢失数据。
  
  - 将改写的地址内容首先复制。
  
  - 因此，如果将较高位地址的数据复制到较低位地址，则复制操作从原块的最低位地址开始并向最高位地址进行。反之，如果要将数据从低地址复制到高地址，复制操作从原块的最高地址开始，向最低地址进行。

#### 使用说明

操作步骤：

1. 查看 `1000:0 - 1000 1F` 的内存内容

2. 复制 `1000:0 - 1000:F` 的内存内容到 `1000:10 - 1000:1F`

3. 再次查看 `1000:0 - 1000 1F` 的内存内容

<img src="file:///E:/notes/Assembly/pics/debug_m_1.PNG" title="" alt="debug_m_1" data-align="center">

### Debug:C（比较）

#### c 命令

含义: 比较内存的两个部分。

使用：

```shell
c range address
```

参数:

- range: <u>指定要比较的内存第一个区域的起始和结束地址，或起始地址和长度</u>。

- address: <u>指定要比较的第二个内存区域的起始地址</u>。

注意：

- 如果 range 和 address 内存区域相同，Debug 将不显示任何内容而直接返回到 Debug 提示符。

- 如果有差异，Debug 将按如下格式显示：`address1 byte1 byte2 addess2`

#### 使用说明

操作步骤：

1. 查看 `1000:10 - 1000:2F` 的内存内容

2. 比较 `1000:10 - 1000:1F` 于 `1000:20 - 1000:2F` 的差异

<img src="file:///E:/notes/Assembly/pics/debug_c_1.PNG" title="" alt="debug_c_1" data-align="center">

## 汇编和反汇编

### Debug:A（汇编）

#### a 命令

含义：直接将 8086/8087/8088 **机器码合并到内存**。该命令<u>从汇编语言语句创建可执行的机器码。所有数值都是十六进制格式，必须按一到四个字符输入这些数值</u>。在引用的操作代码（操作码）前指定前缀机器码。也就是可以输入汇编代码。

使用：

```shell
a [address]
```

参数:

- address: 指定键入汇编语言指令的位置。<u>对 address 使用十六进制值</u>，<u>并键入不以“h”字符结尾的每个值</u>。如果不指定地址，a 将在它上次停止处开始汇编。

注意：

- **使用机器码**
  
  - 段的替代机器码为 `cs:`、`ds:`、`es:` 和 `ss:`。
  
  - 远程返回的机器码是 retf。
  
  - 字符串处理的机器码必须明确声明字符串大小。例如，使用 `mov sw` 可以移动 16 位的字串，使用 `mov sb` 可以移动 8 位字节串。

- **汇编跳转和调用**
  
  - 汇编程序根据字节替换自动将 短、近 和 远 的跳转及调用汇编到目标地址。
  
  - <u>通过使用 `near` 或 `far` 前缀可以替代这样的跳转或调用</u>，可以将 near 前缀缩写为 ne。如下例所示：
    
    ```
    -a 0100:0500
    0100:0500 jmp 502 ; a 2-byte short jump
    0100:0502 jmp near 505 ; a 3-byte near jump
    0100:0505 jmp far 50a ; a 5-byte far jump
    ```

- **区分字和字节内存位置**
  
  - 当某个操作数<u>可以引用某个字内存位置或者字节内存位置时，必须用前缀 `word ptr` 或者前
    缀 `byte ptr` 指定数据类型</u>。
  
  - 可接受的缩写分别是 wo 和 by。以下范例显示两种格式：
    
    ```shell
    dec wo [si]
    neg byte ptr [128]
    ```

-  **指定操作数**
  
  - Debug 使用包括在中括号 ([ ]) 的操作数引用内存地址的习惯用法。这是因为另一方面 Debug 不能区分立即操作数和内存地址的操作数。以下范例显示两种格式：
    
    ```shell
    mov ax,21 ; load AX with 21h
    mov ax,[21] ; load AX with the
    ; contents of
    ; memory location 21h
    ```

- **使用伪指令**
  
  - 使用 a 命令提供两个常用的伪指令：
    
    - db 操作码，将字节值直接汇编到内存
    
    - dw 操作码，将字值直接汇编到内存。
    
    - 以下是两个伪指令的范例：
      
      ```shell
      db 1,2,3,4,"THIS IS AN EXAMPLE"
      db 'THIS IS A QUOTATION MARK:"'
      db "THIS IS A QUOTATION MARK:'"
      dw 1000,2000,3000,"BACH"
      ```

### Debug:U（反汇编）

#### u 指令

含义：**反汇编字节并显示相应的原语句**，其中包括地址和字节值。反汇编代码看起来象已汇编文件的列表。

使用：

```shell
u [range]
```

参数:

- 如果在没有参数的情况下使用，则 u 命令分解 20h 字节（默认值），从前面 u 命令所显示
  地址后的第一个地址开始

- range: <u>指定要反汇编代码的起始地址和结束地址，或起始地址和长度</u>。

#### 使用说明

操作步骤：反汇编 `1000:0 - 1000:1F` 地址段的语句

<img src="file:///E:/notes/Assembly/pics/debug_u_1.PNG" title="" alt="debug_u_1" data-align="center">

## 执行指令

### Debug:P（执行-不进入过程）

#### p 指令

含义：**执行循环、重复的字符串指令、软件中断或子例程；或通过任何其他指令跟踪**。

使用：

```shell
p [= address] [number]
```

参数：

- = address: <u>指定第一个要执行指令的位置</u>。如果不指定地址，则默认地址是在 CS:IP 寄存器中指定的当前地址。

- number: <u>指定在将控制返回给 Debug 之前要执行的指令数。默认值为 1。</u>

注意：

- **控制传送到要测试的程序**
  
  - 当 p 命令将控制从 Debug 传送到要测试的程序时，该程序不间断运行，直到循环、重复字符串指令、软件中断或者完成了指定地址的子例程为止，或者直到执行了指定数量的机器指令为止。控制返回到 Debug。

- **地址参数的限制**
  
  - 如果 address 参数没有指定段，Debug 将使用被测试程序的 CS 寄存器。如果省略 address，程序将从 CS:IP 寄存器所指定的地址开始执行。
  
  - 必须在 address 参数之前使用等号 (=) 以便将它与 number 参数区分。
  
  - **如果在指定地址处的指令不是循环、重复的字符串指令、软件中断或子例程，则 p 命令与 Debug t（跟踪）命令的作用相同。**
  
  - **P 命令不会跟踪进入子程序或软中断，T 命令可以跟踪进入子程序或者软中断**。

- **使用 p 命令显示的标志位状态**
  
  - 当 p 执行完一段说明后，Debug 显示出程序的寄存器内容、标志的状态以及下一段将要被执行的指令的解码形式。

- **警告**
  
  - 不能使用 p 命令跟踪只读内存 (ROM)。

#### 使用说明

操作步骤：使用 p 和 t 进行单步执行

<img title="" src="file:///E:/notes/Assembly/pics/debug_p_1.png" alt="debug_p_1" data-align="center">

### Debug:T（执行-进入过程）

#### t 指令

含义：**执行汇编程序，单步跟踪，并且进入过程**。

使用：

```shell
p [= address] [number]
```

参数见 Debug:P

**P 命令不会跟踪进入子程序或软中断，T 命令可以跟踪进入子程序或者软中断**。

#### 使用说明

见 Debug:P

### Debug:G（转向/断点）

#### g 命令

含义：**运行当前在内存中的程序**。

使用：

```shell
g [=address] [breakpoints]
```

参数:

- =address: <u>指定当前在内存中要开始执行的程序地址</u>。如果不指定 address，Windows 2000 将从 CS:IP 寄存器中的当前地址开始执行程序。

- breakpoints: <u>指定可以设置为 g 命令的部分的 1 到 10 个临时断点</u>。

注意：

**从起始地址开始执行到断点地址。如果不设置断点，则程序一直运行到中止指令才停止**。

#### 使用说明

操作步骤：

1. 先添加一段汇编指令

2. 然后通过 g 命令执行 `g =1000:0 100c` 从`1000:0` 开始，断点在 100c 

## 读写磁盘

### Debug:N（名称）

#### n 命令

含义：**指定 Debug l（加载）或 w（写入）命令的可执行文件的名称，或者指定正在调试的可执行文件的参数**。

使用1：

```shell
n [drive:][path] filename
```

使用2，要指定测试的可执行文件的参数：

```shell
n file-parameters
```

注意：n 命令的两个用途
可以按两种方式使用 n 命令。

- 首先，您可以使用它以指定后面的 l（加载）或 w（写入）命令所使用的文件。
  
  - 如果在没有命名所调试文件的情况下启动 Debug，必须在使用 l 命令加载文件之前使用命令 `n filename`。
  
  - 在 CS:5C 为文件控制块 (FCB) 正确编排文件名的格式。

- 其次，可以使用 n 命令指定被调试文件的命令行参数和开关。
  
  - 内存区域，以下四个内存区域都会受到 n 命令的影响：
    
    - 内存位置：CS:5C，内容：文件 1 的文件控制数据块 (FCB)
    
    - 内存位置：CS:6C，内容：文件 2 的文件控制数据块 (FCB)
    
    - 内存位置：CS:80，内容：n 命令行的长度（以字符表示）
    
    - 内存位置：CS:81，内容：n 命令行字符的开头
  
  - 为 n 命令指定的第一个文件名被放在 CS:5C 的 FCB 中。
  
  - 如果指定第二个文件名，此名称将放置到 CS:6C 的 FCB 中。
  
  - n 命令行上键入的字符数（除第一个字符之外，n）存储在位置 CS:80。
  
  - n 命令行上的实际字符（再次，除了字母 n 之外）存储在以 CS:81 开头的位置。注意这些字符可以是在 Windows 2000 命令提示符下键入的命令中有效的任何开关和分隔符。

### Debug:W（写入）

#### i 命令

含义：**将文件或特定分区写入磁盘**。

要将在 BX:CX 寄存器中指定字节数的内容写入磁盘文件，使用：

```shell
w [address]
```

要略过 Windows 2000 文件系统并直接写入特定的扇区，请使用以下语法：

```shell
w address drive start number
```

参数:

- address: <u>指定要写到磁盘文件的文件或部分文件的起始内存地址</u>。<u>如果不指定 address，Debug 程序将从 CS:100 开始</u>。

- drive: <u>指定包含目标盘的驱动器</u>。该值是数值型：0 = A, 1 = B, 2 = C,等等。

- start: <u>指定要写入第一个扇区的十六进制数</u>。

- number: <u>指定要写入的扇区数</u>。

注意：

- 必须在启动 Debug 时或者在最近的 Debug n（名称）命令中指定磁盘文件的名字。
  
  - 这两种方法都可以将地址 CS:5C 处文件控制块的文件名正确地编排格式。

- 在使用不带参数的 w 命令之前重新设置 BX:CX 

- 如果使用了 Debug g（转向）、t（跟踪）、p（执行）或 r（寄存器）命令，必须在使用无参数的 w 命令之前，将 BX:CX 寄存器复位。

- 将修改后的文件写入磁盘
  
  - 如果修改文件但不更改文件名、长度或起始地址，Debug 仍然可以正确地将文件写入源磁盘位置。

- w 命令的限制
  
  - 不能用该命令写入 .exe 或 .hex 文件。

- 警告
  
  - 因为略过 Windows 2000 文件句柄，所以写入特定的分区非常危险。如果键入错误的值，则磁盘文件结构很容易被损坏。

### Debug:L（加载）

#### l 命令

含义：**将某个文件或特定磁盘扇区的内容加载到内存**。

要从磁盘文件加载 BX:CX 寄存器中指定的字节数内容，使用:

```shell
l [address]
```

要略过 Windows 2000 文件系统并直接加载特定的扇区，使用：

```shell
l address drive start number
```

参数见 debug:W

注意:

- 使用不带参数的 l 命令
  
  - 当使用不带参数的 l 命令时，在 debug 命令行上指定的文件将加载到内存中，从地址 CS:100 开始。Debug 同时将 BX 和 CX 寄存器设置为加载的字节数。
  
  - 如果不在 debug 命令行指定文件，所装入的文件将是最近使用 n 命令经常指定的文件。

- 使用具有 address 参数的 l 命令
  
  - 如果使用带 address 参数的 l 命令，Debug 将从内存位置 address 开始加载文件或指定扇区的内容。

- 使用带全部参数的 l 命令
  
  - 如果使用带所有参数的 l 命令，Debug 将加载指定磁盘扇区的内容而不是加载文件。

- 加载特定扇区的内容
  
  - 指定范围内的每个扇区均从 drive 读取。Debug 从 start 开始加载，直到在 number 中指定的扇区数中的内容全部被加载。

- 加载 .exe 文件
  
  - Debug 忽略 .exe 文件的地址 address 参数。
  
  - 如果指定 .exe 文件，Debug 将文件重新定位到 .exe 文件的标题中指定的加载地址。在 .exe 文件被加载到内存前，标题自身从 .exe 文件脱离，因此磁盘上的 .exe 文件大小与内存中的不同。
  
  - 如果要检查整个 .exe 文件，请使用不同的扩展名重命名文件。

- 打开十六进制文件
  
  - Debug 将具有 .hex 扩展名的文件认为十六进制格式文件。
  
  - 键入不带参数的 l 命令，可以加载从十六进制文件中指定的地址处开始的十六进制文件。
  
  - 如果键入的 l 命令包含 address 参数，Debug 将把指定的地址加到在十六进制文件中找到的地址上，以确定起始地址

## 读写I/O端口

### Debug:I（输入）

#### i 指令

含义：**从指定的端口读取并显示一个字节值**。

使用：

```shell
i port
```

参数:

- port:<u> 按地址指定输入端口。地址可以是 16 位的值</u>。

### Debug:O（输出）

#### o 指令

含义：将字节值发送到输出端口。

使用：

```shell
o port byte-value
```

参数:

- port: <u>通过地址指定输出端口。端口地址可以是 16 位值</u>。

- byte-value: <u>指定要指向 port 的字节值</u>。

## 十六进制加减

### Debug:H（十六进制）

#### h 指令

含义：对指定的两个参数执行十六进制运算。

使用：

```shell
h value1 value2
```

参数:

- value1: 代表从 0 到 FFFFh 范围内的任何十六进制数字。

- value2: 代表从 0 到 FFFFh 范围内第二个十六进制数字。

注意：

Debug 首先将指定的两个参数相加，然后从第一个参数中减去第二个参数。这些计算的结果显示在一行中：先计算和，然后计算差。

#### 使用说明

```shell
-h 19f 10a
# Debug 执行运算并显示以下结果。
02A9 0095
```

## 退出DEBUG

### Debug:Q（退出）

#### q 命令

含义：停止 Debug 会话，不保存当前测试的文件。

使用：

```shell
q
```
